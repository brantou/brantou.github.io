<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">









  <meta name="baidu-site-verification" content="2NCO1zLkcL">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|monospace:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="leetcode,tree,">





  <link rel="alternate" href="/atom.xml" title="Brantou的日常" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="LeetCode 编程训练的积累，目前在努力做题中，日后整理！">
<meta name="keywords" content="leetcode,tree">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-tree">
<meta property="og:url" content="https://brantou.github.io/2017/07/16/leetcode-tree/index.html">
<meta property="og:site_name" content="Brantou的日常">
<meta property="og:description" content="LeetCode 编程训练的积累，目前在努力做题中，日后整理！">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-07-16T07:30:55.768Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode-tree">
<meta name="twitter:description" content="LeetCode 编程训练的积累，目前在努力做题中，日后整理！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brantou.github.io/2017/07/16/leetcode-tree/">





  <title>Leetcode-tree | Brantou的日常</title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-99654689-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a82c2fbb2a57e8b3c01e31a60807a7f6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Brantou的日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">二三事</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://brantou.github.io/2017/07/16/leetcode-tree/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Brantou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/26197076?v=3&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Brantou的日常">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Leetcode-tree</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-16T00:00:00+08:00">
                2017-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术积累/" itemprop="url" rel="index">
                    <span itemprop="name">技术积累</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/16/leetcode-tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/07/16/leetcode-tree/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        

<p>
<i>LeetCode</i> 编程训练的积累，目前在努力做题中，日后整理！
</p>
<a id="more"></a>

<div id="outline-container-org81666c9" class="outline-2">
<h2 id="org81666c9"><a id="ID-a529c358-9cbf-45b3-979e-e5994db34c19"></a><span class="section-number-2">1</span> binary tree traversal</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org95bc559" class="outline-3">
<h3 id="org95bc559"><a id="ID-a750e3ce-df1d-48c3-b1f6-4fcda811b00e"></a><span class="section-number-3">1.1</span> level order</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> levelOrder(root *TreeNode) [][]<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> [][]<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  lo_arr := [][]<span class="typename">int</span>{</span><br><span class="line">    []<span class="typename">int</span>{root.Val},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  llo_arr := levelOrder(root.Left)</span><br><span class="line">  rlo_arr := levelOrder(root.Right)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(llo_arr) &amp;gt; <span class="number">0</span> || <span class="built_in">len</span>(rlo_arr) &amp;gt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">var</span> index <span class="typename">int</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">      <span class="keyword">if</span> index &amp;lt; <span class="built_in">len</span>(llo_arr) &amp;amp;&amp;amp; index &amp;lt; <span class="built_in">len</span>(rlo_arr) {</span><br><span class="line">        lo_arr = <span class="built_in">append</span>(lo_arr, <span class="built_in">append</span>(llo_arr[index], rlo_arr[index]...))</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      }</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(llo_arr) &amp;gt; index {</span><br><span class="line">      lo_arr = <span class="built_in">append</span>(lo_arr, llo_arr[index:]...)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rlo_arr) &amp;gt; index {</span><br><span class="line">      lo_arr = <span class="built_in">append</span>(lo_arr, rlo_arr[index:]...)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lo_arr</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(levelOrder(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(levelOrder(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org4916f8b" class="outline-3">
<h3 id="org4916f8b"><a id="ID-5036a584-d27e-4010-8fb1-ab4255c45b6d"></a><span class="section-number-3">1.2</span> level order bottom</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;lt;&amp;lt;bt-level-order&amp;gt;&amp;gt;</span><br><span class="line"><span class="keyword">func</span> levelOrderBottom(root *TreeNode) [][]<span class="typename">int</span> {</span><br><span class="line">  lo_arr := levelOrder(root)</span><br><span class="line">  lob_arr := <span class="built_in">make</span>([][]<span class="typename">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lo_arr {</span><br><span class="line">    lob_arr = <span class="built_in">append</span>([][]<span class="typename">int</span>{lo_arr[index]}, lob_arr...)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lob_arr</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(levelOrderBottom(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(levelOrderBottom(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org99589c8" class="outline-3">
<h3 id="org99589c8"><a id="ID-09552328-e92c-4a90-be88-6d284ed8aa4d"></a><span class="section-number-3">1.3</span> zigzag level order</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  &amp;lt;&amp;lt;bt-level-order&amp;gt;&amp;gt;</span><br><span class="line">  <span class="keyword">func</span> zigzagLevelOrder(root *TreeNode) [][]<span class="typename">int</span> {</span><br><span class="line">  lo_arr := levelOrder(root)</span><br><span class="line">  zlo_arr := <span class="built_in">make</span>([][]<span class="typename">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lo_arr {</span><br><span class="line">    lo := lo_arr[index]</span><br><span class="line">    <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">1</span> {</span><br><span class="line">      zlo := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lo {</span><br><span class="line">        zlo = <span class="built_in">append</span>([]<span class="typename">int</span>{lo[index]}, zlo...)</span><br><span class="line">      }</span><br><span class="line">      zlo_arr = <span class="built_in">append</span>(zlo_arr, zlo)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      zlo_arr = <span class="built_in">append</span>(zlo_arr, lo)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> zlo_arr</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(zigzagLevelOrder(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(zigzagLevelOrder(root))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org179b5a7" class="outline-3">
<h3 id="org179b5a7"><a id="ID-156ef6af-9e00-464f-9ef5-758b1bde0aa4"></a><span class="section-number-3">1.4</span> inOrder</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> inorderTraversal(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">append</span>(</span><br><span class="line">    <span class="built_in">append</span>(inorderTraversal(root.Left), root.Val),</span><br><span class="line">    inorderTraversal(root.Right)...)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(inorderTraversal(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(inorderTraversal(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-org48a0b0d" class="outline-3">
<h3 id="org48a0b0d"><a id="ID-035f3c1c-8087-4a4c-953c-c7bf5fdc62e2"></a><span class="section-number-3">1.5</span> preOrder</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> preorderTraversal(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">append</span>(</span><br><span class="line">    <span class="built_in">append</span>([]<span class="typename">int</span>{root.Val}, preorderTraversal(root.Left)...),</span><br><span class="line">    preorderTraversal(root.Right)...)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(preorderTraversal(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(preorderTraversal(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-orgf465e82" class="outline-3">
<h3 id="orgf465e82"><a id="ID-7b516e36-8168-4a8e-8a55-b9bba24f6c9e"></a><span class="section-number-3">1.6</span> postOrder</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> postorderTraversal(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">append</span>(</span><br><span class="line">    <span class="built_in">append</span>(postorderTraversal(root.Left), postorderTraversal(root.Right)...),</span><br><span class="line">    root.Val)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(postorderTraversal(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(postorderTraversal(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
</div>

<div id="outline-container-org9e72340" class="outline-2">
<h2 id="org9e72340"><a id="ID-e24cd95c-ddbe-47ce-85b6-d986276eb81e"></a><span class="section-number-2">2</span> binary tree</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeLinkNode {</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> TreeLinkNode *left, *right, *next;</span><br><span class="line"> TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode {</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
</div>
<div id="outline-container-orgce4fb9f" class="outline-3">
<h3 id="orgce4fb9f"><a id="ID-cc2b7bb4-fa77-4385-bd5a-9055059d071b"></a><span class="section-number-3">2.1</span> max depth</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> max(a, b <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> a &amp;gt; b {</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> maxDepth(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(maxDepth(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(maxDepth(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org947f8b1" class="outline-3">
<h3 id="org947f8b1"><a id="ID-48f53fed-a3b6-4299-a156-ce09cdadbdf4"></a><span class="section-number-3">2.2</span> paths</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> binaryTreePaths(root *TreeNode) []<span class="typename">string</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">string</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  str := fmt.Sprintf(<span class="string">"%d"</span>, root.Val)</span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; root.Right == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">string</span>{str}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  paths := <span class="built_in">append</span>(</span><br><span class="line">    binaryTreePaths(root.Left),</span><br><span class="line">    binaryTreePaths(root.Right)...,</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">for</span> index, path := <span class="keyword">range</span> paths {</span><br><span class="line">    paths[index] = str + <span class="string">"-&amp;gt;"</span> + path</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paths</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(binaryTreePaths(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(binaryTreePaths(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org641702f" class="outline-3">
<h3 id="org641702f"><a id="ID-78a7c4b2-2407-4158-9b40-8e827347d923"></a><span class="section-number-3">2.3</span> isBalanced</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;lt;&amp;lt;bt-max-depth&amp;gt;&amp;gt;</span><br><span class="line"><span class="keyword">func</span> isBalanced(root *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ldepth := maxDepth(root.Left)</span><br><span class="line">  rdepth := maxDepth(root.Right)</span><br><span class="line">  ddepth := ldepth - rdepth</span><br><span class="line">  <span class="keyword">if</span> ddepth &amp;gt; <span class="number">1</span> || ddepth &amp;lt; -<span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isBalanced(root.Left) &amp;amp;&amp;amp; isBalanced(root.Right)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(isBalanced(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  fmt.Println(isBalanced(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orgbb0984c" class="outline-3">
<h3 id="orgbb0984c"><a id="ID-391d9e05-93ea-444f-b1b6-9a36da393c97"></a><span class="section-number-3">2.4</span> invert</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> invertTree(root *TreeNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(invertTree(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(invertTree(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org4738885" class="outline-3">
<h3 id="org4738885"><a id="ID-13bd442d-c29e-432b-af05-c5b4909fa259"></a><span class="section-number-3">2.5</span> tilt</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> sumTree(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root.Val + sumTree(root.Left) + sumTree(root.Right)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> abs(num <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> num &amp;lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -num</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> findTilt(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> abs(sumTree(root.Left)-sumTree(root.Right)) +</span><br><span class="line">    findTilt(root.Left) + findTilt(root.Right)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(findTilt(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(findTilt(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org573adcb" class="outline-3">
<h3 id="org573adcb"><a id="ID-ba131b54-0ecf-45d6-8716-fed0c90a48cf"></a><span class="section-number-3">2.6</span> construct string</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> tree2str(t *TreeNode) <span class="typename">string</span> {</span><br><span class="line">  <span class="keyword">if</span> t == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  str := fmt.Sprintf(<span class="string">"%d"</span>, t.Val)</span><br><span class="line">  <span class="keyword">if</span> t.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; t.Right == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> t.Left != <span class="constant">nil</span> {</span><br><span class="line">    str += fmt.Sprintf(<span class="string">"(%s)"</span>, tree2str(t.Left))</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    str += <span class="string">"()"</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> t.Right != <span class="constant">nil</span> {</span><br><span class="line">    str += fmt.Sprintf(<span class="string">"(%s)"</span>, tree2str(t.Right))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org2e15e63" class="outline-3">
<h3 id="org2e15e63"><a id="ID-6dce1c17-7937-4d95-a85a-328fba766396"></a><span class="section-number-3">2.7</span> symmetric</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isSymmetric(root *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isMirror(root.Left, root.Right)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isMirror(lr *TreeNode, rr *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> lr == <span class="constant">nil</span> &amp;amp;&amp;amp; rr == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> lr == <span class="constant">nil</span> || rr == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> lr.Val != rr.Val {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isMirror(lr.Left, rr.Right) &amp;amp;&amp;amp; isMirror(lr.Right, rr.Left)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(isSymmetric(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(isSymmetric(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org007aba8" class="outline-3">
<h3 id="org007aba8"><a id="ID-52dde05d-0a6b-47d0-8061-a406c8b380e0"></a><span class="section-number-3">2.8</span> subtree</h3>
<div class="outline-text-3" id="text-2-8">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isSubtree(s *TreeNode, t *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> t == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s.Val == t.Val {</span><br><span class="line">    <span class="keyword">return</span> isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> isSubtree(s.Left, t) || isSubtree(s.Right, t)</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isSame(s *TreeNode, t *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> s == <span class="constant">nil</span> &amp;amp;&amp;amp; t == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s == <span class="constant">nil</span> || t == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s.Val != t.Val {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSame(s.Left, t.Left) &amp;amp;&amp;amp; isSame(s.Right, t.Right)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  s := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">4</span>,</span><br><span class="line">      Left: &amp;amp;TreeNode{</span><br><span class="line">        Val: <span class="number">1</span>,</span><br><span class="line">      },</span><br><span class="line">      Right: &amp;amp;TreeNode{</span><br><span class="line">        Val: <span class="number">2</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">5</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">4</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(isSubtree(s, t))</span><br><span class="line">  s.Left.Right = &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">0</span>,</span><br><span class="line">  }</span><br><span class="line">  fmt.Println(isSubtree(s, t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org7218791" class="outline-3">
<h3 id="org7218791"><a id="ID-446782d4-2ee6-40f9-94b2-368baddc5fc3"></a><span class="section-number-3">2.9</span> diameter</h3>
<div class="outline-text-3" id="text-2-9">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> diameterOfBinaryTree(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; root.Right == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Right == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">1</span>+maxSide(root.Left), diameterOfBinaryTree(root.Left))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">1</span>+maxSide(root.Right), diameterOfBinaryTree(root.Right))</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max(</span><br><span class="line">    max(</span><br><span class="line">      (<span class="number">2</span>+maxSide(root.Left)+maxSide(root.Right)),</span><br><span class="line">      diameterOfBinaryTree(root.Left),</span><br><span class="line">    ), diameterOfBinaryTree(root.Right))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> maxSide(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; root.Right == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + max(maxSide(root.Left), maxSide(root.Right))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> max(a, b <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> a &amp;gt; b {</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  s := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">4</span>,</span><br><span class="line">      Left: &amp;amp;TreeNode{</span><br><span class="line">        Val: <span class="number">1</span>,</span><br><span class="line">      },</span><br><span class="line">      Right: &amp;amp;TreeNode{</span><br><span class="line">        Val: <span class="number">2</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">5</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">4</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(diameterOfBinaryTree(s))</span><br><span class="line">  fmt.Println(diameterOfBinaryTree(t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org203bb5e" class="outline-3">
<h3 id="org203bb5e"><a id="ID-cd5c03de-ea50-466b-b9ef-4d33ea6c1199"></a><span class="section-number-3">2.10</span> count complete tree nodes</h3>
<div class="outline-text-3" id="text-2-10">
<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode {</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ldepth = <span class="keyword">this</span>-&amp;gt;getLeftDepth(root);</span><br><span class="line">    <span class="keyword">int</span> rdepth = <span class="keyword">this</span>-&amp;gt;getRightDepth(root);</span><br><span class="line">    <span class="keyword">if</span> (ldepth == rdepth) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>-&amp;gt;<span class="built_in">pow</span>(<span class="number">2</span>,ldepth) -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> countNodes(root-&amp;gt;left) + countNodes(root-&amp;gt;right)+<span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getLeftDepth</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+getLeftDepth(root-&amp;gt;left);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRightDepth</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+getRightDepth(root-&amp;gt;right);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>&amp;gt;<span class="number">0</span>) {</span><br><span class="line">      p = p*base;</span><br><span class="line">      <span class="built_in">exp</span> = <span class="built_in">exp</span>- <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  TreeNode* p = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">  p-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">  p-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; s.countNodes(p);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org31d1237" class="outline-3">
<h3 id="org31d1237"><a id="ID-accf2ad8-88b8-4b22-9d5d-f21d703e30f1"></a><span class="section-number-3">2.11</span> implement trie</h3>
<div class="outline-text-3" id="text-2-11">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> {</span><br><span class="line">  is_end <span class="typename">int</span></span><br><span class="line">  next   <span class="keyword">map</span>[<span class="typename">byte</span>]*Trie</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="keyword">func</span> Constructor() Trie {</span><br><span class="line">  <span class="keyword">var</span> trie Trie</span><br><span class="line">  trie.next = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">byte</span>]*Trie)</span><br><span class="line">  <span class="keyword">return</span> trie</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="keyword">func</span> (this *Trie) Insert(word <span class="typename">string</span>) {</span><br><span class="line">  byte_arr := []<span class="typename">byte</span>(word)</span><br><span class="line">  this.insert(byte_arr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (this *Trie) insert(byte_arr []<span class="typename">byte</span>) {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(byte_arr) &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> next_trie, ok := this.next[byte_arr[<span class="number">0</span>]]; ok {</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte_arr) &amp;gt; <span class="number">1</span> {</span><br><span class="line">      next_trie.insert(byte_arr[<span class="number">1</span>:])</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      next_trie.is_end = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    trie := Constructor()</span><br><span class="line">    next_trie := &amp;amp;trie</span><br><span class="line">    this.next[byte_arr[<span class="number">0</span>]] = next_trie</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte_arr) &amp;gt; <span class="number">1</span> {</span><br><span class="line">      next_trie.insert(byte_arr[<span class="number">1</span>:])</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      next_trie.is_end = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="keyword">func</span> (this *Trie) Search(word <span class="typename">string</span>) <span class="typename">bool</span> {</span><br><span class="line">  byte_arr := []<span class="typename">byte</span>(word)</span><br><span class="line">  <span class="keyword">return</span> this.search(byte_arr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (this *Trie) search(byte_arr []<span class="typename">byte</span>) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(byte_arr) &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.next) == <span class="number">0</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> next_trie, ok := this.next[byte_arr[<span class="number">0</span>]]; ok {</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte_arr) == <span class="number">1</span> &amp;amp;&amp;amp; next_trie.is_end == <span class="number">1</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> next_trie.search(byte_arr[<span class="number">1</span>:])</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="keyword">func</span> (this *Trie) StartsWith(prefix <span class="typename">string</span>) <span class="typename">bool</span> {</span><br><span class="line">  byte_arr := []<span class="typename">byte</span>(prefix)</span><br><span class="line">  <span class="keyword">return</span> this.startsWith(byte_arr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (this *Trie) startsWith(byte_arr []<span class="typename">byte</span>) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(byte_arr) &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> next_trie, ok := this.next[byte_arr[<span class="number">0</span>]]; ok {</span><br><span class="line">    <span class="keyword">return</span> next_trie.startsWith(byte_arr[<span class="number">1</span>:])</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * obj := Constructor();</span><br><span class="line"> * obj.Insert(word);</span><br><span class="line"> * param_2 := obj.Search(word);</span><br><span class="line"> * param_3 := obj.StartsWith(prefix);</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  trie := Constructor()</span><br><span class="line">  trie.Insert(<span class="string">"hello"</span>)</span><br><span class="line">  fmt.Println(trie.Search(<span class="string">"hello"</span>))</span><br><span class="line">  fmt.Println(trie.StartsWith(<span class="string">"hello"</span>))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org9d1032b" class="outline-3">
<h3 id="org9d1032b"><a id="ID-23c192e6-e8d0-4082-986a-e5fd82addfe8"></a><span class="section-number-3">2.12</span> merge two binary tree</h3>
<div class="outline-text-3" id="text-2-12">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> t1 == <span class="constant">nil</span> &amp;amp;&amp;amp; t2 == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> t2 == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val:   t1.Val,</span><br><span class="line">      Left:  mergeTrees(t1.Left, <span class="constant">nil</span>),</span><br><span class="line">      Right: mergeTrees(t1.Right, <span class="constant">nil</span>),</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> t1 == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val:   t2.Val,</span><br><span class="line">      Left:  mergeTrees(<span class="constant">nil</span>, t2.Left),</span><br><span class="line">      Right: mergeTrees(<span class="constant">nil</span>, t2.Right),</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">    Val:   t1.Val + t2.Val,</span><br><span class="line">    Left:  mergeTrees(t1.Left, t2.Left),</span><br><span class="line">    Right: mergeTrees(t1.Right, t2.Right),</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t1 := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  t2 := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">2</span>,</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(tree2str(mergeTrees(t1, t2)))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org257add8" class="outline-3">
<h3 id="org257add8"><a id="ID-b65fd60c-7b25-480f-a3b6-7c016cd3129e"></a><span class="section-number-3">2.13</span> flatten bt to linked list</h3>
<div class="outline-text-3" id="text-2-13">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> flatten(root *TreeNode) {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  flatten(root.Left)</span><br><span class="line">  flatten(root.Right)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  lr_r := root.Left</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">if</span> lr_r.Right == <span class="constant">nil</span> {</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    }</span><br><span class="line">    lr_r = lr_r.Right</span><br><span class="line">  }</span><br><span class="line">  lr_r.Right = root.Right</span><br><span class="line"></span><br><span class="line">  root.Right = root.Left</span><br><span class="line">  root.Left = <span class="constant">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">5</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(tree2str(flatten(t)))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orgc380c5d" class="outline-3">
<h3 id="orgc380c5d"><a id="ID-77941cf3-c164-4ca2-8b9b-82e202bd7efe"></a><span class="section-number-3">2.14</span> sum of left leaves</h3>
<div class="outline-text-3" id="text-2-14">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> sumOfLeftLeaves(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; root.Right == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left != <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">if</span> isLeave(root.Left) {</span><br><span class="line">      <span class="keyword">return</span> root.Left.Val + sumOfLeftLeaves(root.Right)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.Right)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isLeave(node *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">return</span> node.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; node.Right == <span class="constant">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">3</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">9</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">20</span>,</span><br><span class="line">      Left: &amp;amp;TreeNode{Val: <span class="number">15</span>},</span><br><span class="line">      Right: &amp;amp;TreeNode{Val: <span class="number">7</span>},</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(sumOfLeftLeaves(t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org2ca0ba3" class="outline-3">
<h3 id="org2ca0ba3"><a id="ID-2dc7a649-b0b8-45a2-b07f-b950998d5b85"></a><span class="section-number-3">2.15</span> find bottom left tree value</h3>
<div class="outline-text-3" id="text-2-15">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> findBottomLeftValue(root *TreeNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  lnode_arr := []*TreeNode{root}</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    n_lnode_arr := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lnode_arr {</span><br><span class="line">      node := lnode_arr[index]</span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="constant">nil</span> {</span><br><span class="line">        n_lnode_arr = <span class="built_in">append</span>(n_lnode_arr, node.Left)</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="constant">nil</span> {</span><br><span class="line">        n_lnode_arr = <span class="built_in">append</span>(n_lnode_arr, node.Right)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(n_lnode_arr) &amp;gt; <span class="number">0</span> {</span><br><span class="line">      lnode_arr = n_lnode_arr</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lnode_arr[<span class="number">0</span>].Val</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">5</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">10</span>},</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(findBottomLeftValue(t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-org47816be" class="outline-3">
<h3 id="org47816be"><a id="ID-d4457233-b607-4100-8ace-2fddd2ec6470"></a><span class="section-number-3">2.16</span> right side view</h3>
<div class="outline-text-3" id="text-2-16">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> rightSideView(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  lnode_arr := []*TreeNode{root}</span><br><span class="line">  rsv_arr := []<span class="typename">int</span>{root.Val}</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    n_lnode_arr := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lnode_arr {</span><br><span class="line">      node := lnode_arr[index]</span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="constant">nil</span> {</span><br><span class="line">        n_lnode_arr = <span class="built_in">append</span>(n_lnode_arr, node.Left)</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="constant">nil</span> {</span><br><span class="line">        n_lnode_arr = <span class="built_in">append</span>(n_lnode_arr, node.Right)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(n_lnode_arr) &amp;gt; <span class="number">0</span> {</span><br><span class="line">      rsv_arr = <span class="built_in">append</span>(rsv_arr, n_lnode_arr[<span class="built_in">len</span>(n_lnode_arr)-<span class="number">1</span>].Val)</span><br><span class="line">      lnode_arr = n_lnode_arr</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rsv_arr</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">5</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(rightSideView(t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-org185b32e" class="outline-3">
<h3 id="org185b32e"><a id="ID-70ebfc01-fe3a-458a-a0eb-c5c281bef831"></a><span class="section-number-3">2.17</span> find largest value in each tree row</h3>
<div class="outline-text-3" id="text-2-17">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> largestValues(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  lnode_arr := []*TreeNode{root}</span><br><span class="line">  rmax_arr := []<span class="typename">int</span>{root.Val}</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    n_lnode_arr := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lnode_arr {</span><br><span class="line">      node := lnode_arr[index]</span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="constant">nil</span> {</span><br><span class="line">        n_lnode_arr = <span class="built_in">append</span>(n_lnode_arr, node.Left)</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="constant">nil</span> {</span><br><span class="line">        n_lnode_arr = <span class="built_in">append</span>(n_lnode_arr, node.Right)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(n_lnode_arr) &amp;gt; <span class="number">0</span> {</span><br><span class="line">      rmax_val := n_lnode_arr[<span class="number">0</span>].Val</span><br><span class="line">      <span class="keyword">for</span> index, _ := <span class="keyword">range</span> n_lnode_arr {</span><br><span class="line">        node := n_lnode_arr[index]</span><br><span class="line">        <span class="keyword">if</span> node.Val &amp;gt; rmax_val {</span><br><span class="line">          rmax_val = node.Val</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      lnode_arr = n_lnode_arr</span><br><span class="line">      rmax_arr = <span class="built_in">append</span>(rmax_arr, rmax_val)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rmax_arr</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">5</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(largestValues(t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-orgeb9e78e" class="outline-3">
<h3 id="orgeb9e78e"><a id="ID-a978c2c9-373f-416c-89d1-0fa0ff5168a0"></a><span class="section-number-3">2.18</span> most frequent subtree sum</h3>
<div class="outline-text-3" id="text-2-18">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> findFrequentTreeSum(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sum_M := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>)</span><br><span class="line">  collectTreeSum(root, sum_M)</span><br><span class="line">  <span class="keyword">var</span> max_count <span class="typename">int</span></span><br><span class="line">  <span class="keyword">for</span> _, count := <span class="keyword">range</span> sum_M {</span><br><span class="line">    <span class="keyword">if</span> count &amp;gt; max_count {</span><br><span class="line">      max_count = count</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ft_sum_arr := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> sum, count := <span class="keyword">range</span> sum_M {</span><br><span class="line">    <span class="keyword">if</span> count == max_count {</span><br><span class="line">      ft_sum_arr = <span class="built_in">append</span>(ft_sum_arr, sum)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ft_sum_arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> collectTreeSum(root *TreeNode, sum_M <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  sum := collectTreeSum(root.Left, sum_M) + root.Val + collectTreeSum(root.Right, sum_M)</span><br><span class="line">  sum_M[sum] = sum_M[sum] + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">5</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(findFrequentTreeSum(t))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orgb18b487" class="outline-3">
<h3 id="orgb18b487"><a id="ID-c41da033-f55b-4491-acf6-c0cb33be3fea"></a><span class="section-number-3">2.19</span> construct binary tree from preorder and inorder traversal</h3>
<div class="outline-text-3" id="text-2-19">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> buildTree(preorder []<span class="typename">int</span>, inorder []<span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val: preorder[<span class="number">0</span>],</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  rio_index := find(inorder, preorder[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">    Val:   preorder[<span class="number">0</span>],</span><br><span class="line">    Left:  buildTree(preorder[<span class="number">1</span>:rio_index+<span class="number">1</span>], inorder[<span class="number">0</span>:rio_index]),</span><br><span class="line">    Right: buildTree(preorder[rio_index+<span class="number">1</span>:], inorder[rio_index+<span class="number">1</span>:]),</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> find(a []<span class="typename">int</span>, x <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">for</span> index, _ := <span class="keyword">range</span> a {</span><br><span class="line">    <span class="keyword">if</span> a[index] == x {</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>


<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  fmt.Println(tree2str(buildTree([]<span class="typename">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, []<span class="typename">int</span>{<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>})))</span><br><span class="line">  fmt.Println(tree2str(buildTree([]<span class="typename">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>}, []<span class="typename">int</span>{<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>})))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org5105443" class="outline-3">
<h3 id="org5105443"><a id="ID-a607f754-361d-4b9f-9618-94b50d36394b"></a><span class="section-number-3">2.20</span> construct binary tree from inorder and postorder traversal</h3>
<div class="outline-text-3" id="text-2-20">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> buildTree(inorder []<span class="typename">int</span>, postorder []<span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{Val: inorder[<span class="number">0</span>]}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  rio_index := find(inorder, postorder[<span class="built_in">len</span>(postorder)-<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">    Val:   postorder[<span class="built_in">len</span>(postorder)-<span class="number">1</span>],</span><br><span class="line">    Left:  buildTree(inorder[<span class="number">0</span>:rio_index], postorder[<span class="number">0</span>:rio_index]),</span><br><span class="line">    Right: buildTree(inorder[rio_index+<span class="number">1</span>:], postorder[rio_index:(<span class="built_in">len</span>(postorder)-<span class="number">1</span>)]),</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> find(a []<span class="typename">int</span>, x <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">for</span> index, _ := <span class="keyword">range</span> a {</span><br><span class="line">    <span class="keyword">if</span> a[index] == x {</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  fmt.Println(tree2str(buildTree([]<span class="typename">int</span>{<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>}, []<span class="typename">int</span>{<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>})))</span><br><span class="line">  fmt.Println(tree2str(buildTree([]<span class="typename">int</span>{<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>}, []<span class="typename">int</span>{<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>})))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orgd015965" class="outline-3">
<h3 id="orgd015965"><a id="ID-0133ef0a-4b13-4ced-a7e4-c245996fb63f"></a><span class="section-number-3">2.21</span> populating next right pointers in each node</h3>
<div class="outline-text-3" id="text-2-21">
<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeLinkNode {</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeLinkNode *left, *right, *next;</span><br><span class="line">  TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ConnectObj {</span><br><span class="line">  TreeLinkNode *left_most;</span><br><span class="line">  TreeLinkNode *right_most;</span><br><span class="line">  ConnectObj() : left_most(<span class="literal">NULL</span>), right_most(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt;</span><br><span class="line">mergeConnect(</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; lc_dq,</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; rc_dq)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt;::iterator it = lc_dq.begin(); it != lc_dq.end(); ++it) {</span><br><span class="line">    <span class="keyword">if</span> (it-&amp;gt;right_most == <span class="literal">NULL</span>) {</span><br><span class="line">      it-&amp;gt;right_most = it-&amp;gt;left_most;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt;::iterator it = rc_dq.begin(); it != rc_dq.end(); ++it) {</span><br><span class="line">    <span class="keyword">if</span> (it-&amp;gt;left_most == <span class="literal">NULL</span>) {</span><br><span class="line">      it-&amp;gt;left_most = it-&amp;gt;right_most;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> min_size = lc_dq.size() &amp;lt; rc_dq.size() ? lc_dq.size() : rc_dq.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &amp;lt; min_size; index+=<span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">if</span> (lc_dq[index].right_most != <span class="literal">NULL</span> &amp;amp;&amp;amp; rc_dq[index].left_most != <span class="literal">NULL</span>){</span><br><span class="line">      lc_dq[index].right_most-&amp;gt;next = rc_dq[index].left_most;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    lc_dq[index].right_most = rc_dq[index].right_most;</span><br><span class="line">    rc_dq[index].left_most = lc_dq[index].left_most;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lc_dq.size() &amp;gt; rc_dq.size() ? lc_dq : rc_dq;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&amp;gt;connectHelper(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; connectHelper(TreeLinkNode *root) {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; conn_dq;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> conn_dq;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ConnectObj rc_node;</span><br><span class="line">    rc_node.left_most = root;</span><br><span class="line">    rc_node.right_most = root;</span><br><span class="line">    <span class="keyword">if</span> ((root-&amp;gt;left == <span class="literal">NULL</span>) &amp;amp;&amp;amp; (root-&amp;gt;right == <span class="literal">NULL</span>)) {</span><br><span class="line">      conn_dq.push_back(rc_node);</span><br><span class="line">      <span class="keyword">return</span> conn_dq;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; lc_dq = connectHelper(root-&amp;gt;left);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; rc_dq = connectHelper(root-&amp;gt;right);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&amp;lt;ConnectObj&amp;gt; merge_dq = mergeConnect(lc_dq, rc_dq);</span><br><span class="line">    merge_dq.push_front(rc_node);</span><br><span class="line">    <span class="keyword">return</span> merge_dq;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  TreeLinkNode* p = <span class="keyword">new</span> TreeLinkNode(<span class="number">5</span>);</span><br><span class="line">  p-&amp;gt;left = <span class="keyword">new</span> TreeLinkNode(<span class="number">3</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;left = <span class="keyword">new</span> TreeLinkNode(<span class="number">1</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;left-&amp;gt;left = <span class="keyword">new</span> TreeLinkNode(<span class="number">1</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;right = <span class="keyword">new</span> TreeLinkNode(<span class="number">2</span>);</span><br><span class="line">  p-&amp;gt;right = <span class="keyword">new</span> TreeLinkNode(<span class="number">7</span>);</span><br><span class="line">  p-&amp;gt;right-&amp;gt;right = <span class="keyword">new</span> TreeLinkNode(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  Solution s;</span><br><span class="line">  s.connect(p);</span><br><span class="line">  TreeLinkNode *left = p;</span><br><span class="line">  <span class="keyword">while</span> (left != <span class="literal">NULL</span>) {</span><br><span class="line">      TreeLinkNode *head = left;</span><br><span class="line">      <span class="keyword">while</span> (head !=<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; head-&amp;gt;val &amp;lt;&amp;lt; <span class="string">" "</span>;</span><br><span class="line">        head = head-&amp;gt;next;</span><br><span class="line">      }</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; <span class="string">"\n"</span>;</span><br><span class="line">      left = left-&amp;gt;left;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org2642c0d" class="outline-3">
<h3 id="org2642c0d"><a id="ID-8c454d5c-9e2e-4bb4-942b-1342e79055ad"></a><span class="section-number-3">2.22</span> add one row to tree</h3>
<div class="outline-text-3" id="text-2-22">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> addOneRow(root *TreeNode, v <span class="typename">int</span>, d <span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> d == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val:  v,</span><br><span class="line">      Left: root,</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> || d &amp;lt; <span class="number">2</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addOneRowHelper(root, v, d)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> addOneRowHelper(root *TreeNode, v <span class="typename">int</span>, d <span class="typename">int</span>) {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> d == <span class="number">2</span> {</span><br><span class="line">    root.Left = &amp;amp;TreeNode{</span><br><span class="line">      Val:  v,</span><br><span class="line">      Left: root.Left,</span><br><span class="line">    }</span><br><span class="line">    root.Right = &amp;amp;TreeNode{</span><br><span class="line">      Val:   v,</span><br><span class="line">      Right: root.Right,</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  addOneRowHelper(root.Left, v, d-<span class="number">1</span>)</span><br><span class="line">  addOneRowHelper(root.Right, v, d-<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">3</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">4</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(tree2str(addOneRow(root, <span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">  fmt.Println(tree2str(addOneRow(root, <span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org8a9cddd" class="outline-3">
<h3 id="org8a9cddd"><a id="ID-c89996d5-e334-4ca4-8ffe-bef6711710fa"></a><span class="section-number-3">2.23</span> lowest common ancestor of a bt</h3>
<div class="outline-text-3" id="text-2-23">
<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || p == root || q == root) {</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode *left = lowestCommonAncestor(root-&amp;gt;left, p, q);</span><br><span class="line">    TreeNode *right = lowestCommonAncestor(root-&amp;gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;amp;&amp;amp; right != <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  TreeNode* p = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">  p-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;left-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">  p-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">  p-&amp;gt;right-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; s.lowestCommonAncestor(p, p-&amp;gt;left-&amp;gt;left, p-&amp;gt;right-&amp;gt;right)-&amp;gt;val;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; s.lowestCommonAncestor(p, p-&amp;gt;left-&amp;gt;left, p-&amp;gt;left-&amp;gt;right)-&amp;gt;val;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org4454e8a" class="outline-3">
<h3 id="org4454e8a"><a id="ID-ac4a74b1-6ba3-4527-a89c-6ba44b08d46c"></a><span class="section-number-3">2.24</span> serialize and deserialize bt</h3>
<div class="outline-text-3" id="text-2-24">
<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;lt;&amp;lt;bt-node-def-cpp&amp;gt;&amp;gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_bracket_end</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> b_start)</span> </span>{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&amp;lt;<span class="keyword">char</span>&amp;gt;  b_stack;</span><br><span class="line">  <span class="keyword">int</span> b_end=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = b_start; index &amp;lt; str.size(); index += <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">char</span> c = str[index];</span><br><span class="line">    <span class="keyword">switch</span> (c) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">      b_stack.push(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">      b_stack.pop();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (b_stack.empty()==<span class="literal">true</span>) {</span><br><span class="line">      b_end = index;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> b_end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ostringstream</span> os;</span><br><span class="line">  os &amp;lt;&amp;lt; t-&amp;gt;val;</span><br><span class="line">  <span class="keyword">if</span> (t-&amp;gt;left == <span class="literal">NULL</span> &amp;amp;&amp;amp; t-&amp;gt;right == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">return</span> os.str();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (t-&amp;gt;left != <span class="literal">NULL</span>) {</span><br><span class="line">    os &amp;lt;&amp;lt; <span class="string">"("</span> &amp;lt;&amp;lt; tree2str(t-&amp;gt;left) &amp;lt;&amp;lt; <span class="string">")"</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    os &amp;lt;&amp;lt; <span class="string">"()"</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (t-&amp;gt;right != <span class="literal">NULL</span>) {</span><br><span class="line">    os &amp;lt;&amp;lt; <span class="string">"("</span> &amp;lt;&amp;lt; tree2str(t-&amp;gt;right) &amp;lt;&amp;lt; <span class="string">")"</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> os.str();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> str)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="string">""</span> || str  == <span class="string">"()"</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> b_start = str.find(<span class="string">"("</span>);</span><br><span class="line">  <span class="keyword">if</span> (b_start &amp;lt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">std</span>::atoi(str.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> num_str = str.substr(<span class="number">0</span>, b_start);</span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">std</span>::atoi(num_str.c_str());</span><br><span class="line">  TreeNode* root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> b_end = find_bracket_end(str, b_start);</span><br><span class="line">  <span class="keyword">if</span> (b_end-b_start &amp;gt; <span class="number">1</span>) {</span><br><span class="line">    root-&amp;gt;left = str2tree(str.substr(b_start+<span class="number">1</span>, b_end));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  b_start = b_end+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (b_start &amp;lt; str.size() &amp;amp;&amp;amp; str[b_start]==<span class="string">'('</span>){</span><br><span class="line">    b_end = find_bracket_end(str, b_start);</span><br><span class="line">    <span class="keyword">if</span> (b_end-b_start &amp;gt; <span class="number">1</span>) {</span><br><span class="line">      root-&amp;gt;right = str2tree(str.substr(b_start+<span class="number">1</span>, b_end));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Codec {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tree2str(root);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> str2tree(data);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  TreeNode* p = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">  p-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;left-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">  p-&amp;gt;left-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">  p-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">  p-&amp;gt;right-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  Codec codec;</span><br><span class="line">  <span class="built_in">string</span> encode_str =codec.serialize(p);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; encode_str &amp;lt;&amp;lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  TreeNode* np = codec.deserialize(encode_str);</span><br><span class="line">  encode_str = codec.serialize(np);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; encode_str &amp;lt;&amp;lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-org03d5a15" class="outline-3">
<h3 id="org03d5a15"><a id="ID-7486a488-a366-4a21-9a8d-408e6bc2f779"></a><span class="section-number-3">2.25</span> average of levels in binary tree</h3>
<div class="outline-text-3" id="text-2-25">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> averageOfLevels(root *TreeNode) []<span class="typename">float64</span> {</span><br><span class="line">  lo_arr := levelOrder(root)</span><br><span class="line">  aveOfLevels := <span class="built_in">make</span>([]<span class="typename">float64</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> index, _ := <span class="keyword">range</span> lo_arr {</span><br><span class="line">    lo := lo_arr[index]</span><br><span class="line">    <span class="keyword">var</span> sum <span class="typename">int</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> lo {</span><br><span class="line">      sum += val</span><br><span class="line">    }</span><br><span class="line">    ave := <span class="typename">float64</span>(sum) / <span class="typename">float64</span>(<span class="built_in">len</span>(lo))</span><br><span class="line">    aveOfLevels = <span class="built_in">append</span>(aveOfLevels, ave)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> aveOfLevels</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(averageOfLevels(root))</span><br><span class="line">  root.Left.Left = &amp;amp;TreeNode{Val:<span class="number">4</span>}</span><br><span class="line">  root.Right.Right = &amp;amp;TreeNode{Val:<span class="number">5</span>}</span><br><span class="line">  fmt.Println(averageOfLevels(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-org3fd398c" class="outline-3">
<h3 id="org3fd398c"><a id="ID-85be3858-4d8f-4e28-b192-05c19ea8046c"></a><span class="section-number-3">2.26</span> <span class="todo TODO">TODO</span> house robber III</h3>
<div class="outline-text-3" id="text-2-26">
</div>
</div>
</div>
<div id="outline-container-orgd6bb2d9" class="outline-2">
<h2 id="orgd6bb2d9"><a id="ID-ae065479-6002-4220-ac17-8976f4422fe2"></a><span class="section-number-2">3</span> bst</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org1f1e469" class="outline-3">
<h3 id="org1f1e469"><a id="ID-1bfec43c-1148-4a87-bb9d-461da564809b"></a><span class="section-number-3">3.1</span> BSTIterator</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode {</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line">  TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node {</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *next;</span><br><span class="line">  Node(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">convertBST2SortedLst</span><span class="params">(TreeNode *lct,TreeNode *pn, TreeNode *rct)</span> </span>{</span><br><span class="line">  Node *lhead = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (lct != <span class="literal">NULL</span>) {</span><br><span class="line">    lhead = convertBST2SortedLst(lct-&amp;gt;left, lct, lct-&amp;gt;right);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Node *pln = <span class="keyword">new</span> Node(pn-&amp;gt;val);</span><br><span class="line"></span><br><span class="line">  Node *rhead = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (rct != <span class="literal">NULL</span>){</span><br><span class="line">    rhead = convertBST2SortedLst(rct-&amp;gt;left, rct, rct-&amp;gt;right);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Node *head = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (lhead != <span class="literal">NULL</span>) {</span><br><span class="line">    pln-&amp;gt;next = rhead;</span><br><span class="line">    head = lhead;</span><br><span class="line">    <span class="keyword">while</span> (lhead-&amp;gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">      lhead = lhead-&amp;gt;next;</span><br><span class="line">    }</span><br><span class="line">    lhead-&amp;gt;next = pln;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    pln-&amp;gt;next = rhead;</span><br><span class="line">    head = pln;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BSTIterator {</span><br><span class="line">  Node* head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BSTIterator(TreeNode *root) {</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) {</span><br><span class="line">      head = convertBST2SortedLst(root-&amp;gt;left, root, root-&amp;gt;right);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      head = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&amp;gt;head != <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&amp;gt;head== <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node *oldHead = head;</span><br><span class="line">    head = head-&amp;gt;next;</span><br><span class="line">    <span class="keyword">int</span> num = oldHead-&amp;gt;val;</span><br><span class="line">    <span class="keyword">delete</span> oldHead;</span><br><span class="line">    oldHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~BSTIterator(){</span><br><span class="line">    Node *oldHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>){</span><br><span class="line">      oldHead = head;</span><br><span class="line">      head = head-&amp;gt;next;</span><br><span class="line">      <span class="keyword">delete</span> oldHead;</span><br><span class="line">      oldHead = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) cout &amp;lt;&amp;lt; i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  TreeNode* p = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">  p-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">  p-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  BSTIterator i = BSTIterator(p);</span><br><span class="line">  <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; i.next();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org5c97f54" class="outline-3">
<h3 id="org5c97f54"><a id="ID-428464e7-5a33-4402-bfb3-c26263d807bd"></a><span class="section-number-3">3.2</span> to greater tree</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> convertBST(root *TreeNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> convertBSTHelper(root, <span class="number">0</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> convertBSTHelper(root *TreeNode, upper <span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="constant">nil</span> &amp;amp;&amp;amp; root.Right == <span class="constant">nil</span> {</span><br><span class="line">    root.Val += upper</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Right != <span class="constant">nil</span> {</span><br><span class="line">    minNode := findMinBST(root.Right)</span><br><span class="line">    root.Right = convertBSTHelper(root.Right, upper)</span><br><span class="line">    root.Val += minNode.Val</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    root.Val += upper</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Left != <span class="constant">nil</span> {</span><br><span class="line">    root.Left = convertBSTHelper(root.Left, root.Val)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> findMinBST(root *TreeNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> || root.Left == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> findMinBST(root.Left)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">0</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: -<span class="number">1</span>,</span><br><span class="line">      Left: &amp;amp;TreeNode{</span><br><span class="line">        Val: -<span class="number">3</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">      Right: &amp;amp;TreeNode{</span><br><span class="line">        Val: <span class="number">4</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(convertBST(root))</span><br><span class="line">  fmt.Println(root.Left)</span><br><span class="line">  fmt.Println(root.Left.Left)</span><br><span class="line">  fmt.Println(root.Right.Right)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orgca420d1" class="outline-3">
<h3 id="orgca420d1"><a id="ID-a499ddc4-6eb0-4101-93f7-43b34155752d"></a><span class="section-number-3">3.3</span> validate</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isValidBST(root *TreeNode) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isValidLeftBST(root.Left, root.Val) &amp;amp;&amp;amp; isValidRightBST(root.Right, root.Val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isValidLeftBST(root *TreeNode, upper <span class="typename">int</span>) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val &amp;gt;= upper {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isValidLeftBST(root.Left, root.Val) &amp;amp;&amp;amp; isValidSubBST(root.Right, root.Val, upper)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isValidRightBST(root *TreeNode, lower <span class="typename">int</span>) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val &amp;lt;= lower {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isValidRightBST(root.Right, root.Val) &amp;amp;&amp;amp; isValidSubBST(root.Left, lower, root.Val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> isValidSubBST(root *TreeNode, lower <span class="typename">int</span>, upper <span class="typename">int</span>) <span class="typename">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val &amp;gt;= upper || root.Val &amp;lt;= lower {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isValidSubBST(root.Left, lower, root.Val) &amp;amp;&amp;amp; isValidSubBST(root.Right, root.Val, upper)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(isValidBST(root))</span><br><span class="line"></span><br><span class="line">  root = &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">2</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">  fmt.Println(isValidBST(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org43f72e4" class="outline-3">
<h3 id="org43f72e4"><a id="ID-a208e4f0-6f9f-4e25-a9e7-75d5ef98b574"></a><span class="section-number-3">3.4</span> find mode</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> findMode(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  modes := collect(root)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(modes) &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> modes</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &amp;lt; <span class="built_in">len</span>(modes); i += <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">for</span> j := i; j &amp;gt; <span class="number">0</span>; j -= <span class="number">1</span> {</span><br><span class="line">      <span class="keyword">if</span> modes[j] &amp;lt; modes[j-<span class="number">1</span>] {</span><br><span class="line">        modes[j], modes[j-<span class="number">1</span>] = modes[j-<span class="number">1</span>], modes[j]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> max_count <span class="typename">int</span></span><br><span class="line">  <span class="keyword">var</span> count <span class="typename">int</span></span><br><span class="line">  <span class="keyword">var</span> pre <span class="typename">int</span></span><br><span class="line">  n_modes := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> index, mode := <span class="keyword">range</span> modes {</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> {</span><br><span class="line">      max_count = <span class="number">1</span></span><br><span class="line">      pre = mode</span><br><span class="line">      count = <span class="number">1</span></span><br><span class="line">      n_modes = <span class="built_in">append</span>(n_modes, mode)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mode == pre {</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mode != pre {</span><br><span class="line">      pre = mode</span><br><span class="line">      count = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count == max_count {</span><br><span class="line">      n_modes = <span class="built_in">append</span>(n_modes, mode)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> count &amp;gt; max_count {</span><br><span class="line">      max_count = count</span><br><span class="line">      n_modes = []<span class="typename">int</span>{mode}</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n_modes</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> collect(root *TreeNode) []<span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []<span class="typename">int</span>{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(collect(root.Left), root.Val), collect(root.Right)...)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  root := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">0</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: -<span class="number">1</span>,</span><br><span class="line">      Left: &amp;amp;TreeNode{</span><br><span class="line">        Val: -<span class="number">1</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">2</span>,</span><br><span class="line">      Right: &amp;amp;TreeNode{</span><br><span class="line">        Val: <span class="number">2</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(findMode(root))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orge41cb44" class="outline-3">
<h3 id="orge41cb44"><a id="ID-b9dda316-28f2-4023-8a94-78cc8429bb7a"></a><span class="section-number-3">3.5</span> convert sorted array to bst</h3>
<div class="outline-text-3" id="text-3-5">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> sortedArrayToBST(nums []<span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val: nums[<span class="number">0</span>],</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val: nums[<span class="number">1</span>],</span><br><span class="line">      Left: &amp;amp;TreeNode{</span><br><span class="line">        Val: nums[<span class="number">0</span>],</span><br><span class="line">      },</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">    Val:   nums[mid],</span><br><span class="line">    Left:  sortedArrayToBST(nums[:mid]),</span><br><span class="line">    Right: sortedArrayToBST(nums[mid+<span class="number">1</span>:]),</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  fmt.Println(tree2str(sortedArrayToBST([]<span class="typename">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>})))</span><br><span class="line">  fmt.Println(tree2str(sortedArrayToBST([]<span class="typename">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>})))</span><br><span class="line">  fmt.Println(tree2str(sortedArrayToBST([]<span class="typename">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>})))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org5d2f1cc" class="outline-3">
<h3 id="org5d2f1cc"><a id="ID-e0a572a9-3a7b-4b13-ac8f-588b0a53b0b3"></a><span class="section-number-3">3.6</span> lowest common ancestor</h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode {</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line">  TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&amp;gt;val &amp;gt; q-&amp;gt;val) {</span><br><span class="line">      TreeNode *tmp = p;</span><br><span class="line">      p=q;</span><br><span class="line">      q=tmp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&amp;gt;val&amp;gt;p-&amp;gt;val &amp;amp;&amp;amp; root-&amp;gt;val&amp;lt;q-&amp;gt;val) {</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&amp;gt;val &amp;lt; p-&amp;gt;val) {</span><br><span class="line">      <span class="keyword">return</span> lowestCommonAncestor(root-&amp;gt;right, p, q);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&amp;gt;val &amp;gt; q-&amp;gt;val) {</span><br><span class="line">      <span class="keyword">return</span> lowestCommonAncestor(root-&amp;gt;left, p, q);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&amp;gt;val == p-&amp;gt;val) {</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&amp;gt;val == q-&amp;gt;val) {</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  TreeNode* p = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">  p-&amp;gt;left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">  p-&amp;gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  Solution  s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &amp;lt;&amp;lt; s.lowestCommonAncestor(p, p-&amp;gt;left, p-&amp;gt;right)-&amp;gt;val;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org7672421" class="outline-3">
<h3 id="org7672421"><a id="ID-0d73f7ee-42ee-4475-86b3-70aa3d90a0f5"></a><span class="section-number-3">3.7</span> recover binary search tree</h3>
<div class="outline-text-3" id="text-3-7">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RecoverNode <span class="keyword">struct</span> {</span><br><span class="line">  Pre        *TreeNode</span><br><span class="line">  Ppre       *TreeNode</span><br><span class="line">  Is_recover <span class="typename">int</span></span><br><span class="line">  Illegal    *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> traversalFunc <span class="keyword">func</span>(*TreeNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> recoverTree(root *TreeNode) {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  rNode := &amp;amp;RecoverNode{}</span><br><span class="line">  tfunc := <span class="keyword">func</span>(rnode *RecoverNode) traversalFunc {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">func</span>(node *TreeNode) {</span><br><span class="line">      recoverFunc(node, rnode)</span><br><span class="line">    }</span><br><span class="line">  }(rNode)</span><br><span class="line">  inorderTraversal(root, tfunc)</span><br><span class="line">  <span class="keyword">if</span> rNode.Is_recover == <span class="number">0</span> &amp;amp;&amp;amp; rNode.Illegal != <span class="constant">nil</span> {</span><br><span class="line">    rNode.Pre.Val, rNode.Illegal.Val = rNode.Illegal.Val, rNode.Pre.Val</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> inorderTraversal(root *TreeNode, tfunc traversalFunc) {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  inorderTraversal(root.Left, tfunc)</span><br><span class="line">  tfunc(root)</span><br><span class="line">  inorderTraversal(root.Right, tfunc)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> recoverFunc(node *TreeNode, rnode *RecoverNode) {</span><br><span class="line">  <span class="keyword">if</span> node == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> rnode.Is_recover == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> rnode.Pre == <span class="constant">nil</span> {</span><br><span class="line">    rnode.Pre = node</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> node.Val &amp;lt; rnode.Pre.Val {</span><br><span class="line">    <span class="keyword">if</span> rnode.Illegal == <span class="constant">nil</span> {</span><br><span class="line">      rnode.Illegal = rnode.Pre</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      rnode.Illegal.Val, node.Val = node.Val, rnode.Illegal.Val</span><br><span class="line">      rnode.Is_recover = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> rnode.Illegal != <span class="constant">nil</span> {</span><br><span class="line">      <span class="keyword">if</span> rnode.Illegal.Val &amp;lt; node.Val {</span><br><span class="line">        rnode.Illegal.Val, rnode.Pre.Val = rnode.Pre.Val, rnode.Illegal.Val</span><br><span class="line">        rnode.Is_recover = <span class="number">1</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  rnode.Ppre = rnode.Pre</span><br><span class="line">  rnode.Pre = node</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  s := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">2</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(tree2str(s))</span><br><span class="line">  recoverTree(s)</span><br><span class="line">  fmt.Println(tree2str(s))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org43f3eae" class="outline-3">
<h3 id="org43f3eae"><a id="ID-01439db5-32f2-4792-b0ba-bd1cbd0fcab6"></a><span class="section-number-3">3.8</span> delete node</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> deleteNode(root *TreeNode, key <span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val == key {</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="constant">nil</span> || root.Right == <span class="constant">nil</span> {</span><br><span class="line">      <span class="keyword">if</span> root.Left != <span class="constant">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> root.Left</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> root.Right != <span class="constant">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> root.Right</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      successor := treeMinimum(root.Right)</span><br><span class="line">      root.Val = successor.Val</span><br><span class="line">      root.Right = deleteNode(root.Right, successor.Val)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val &amp;lt; key {</span><br><span class="line">    root.Right = deleteNode(root.Right, key)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    root.Left = deleteNode(root.Left, key)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> treeMinimum(node *TreeNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> node.Left != <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> treeMinimum(node.Left)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  s := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">2</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">    Right: &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">3</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(tree2str(s))</span><br><span class="line">  s = deleteNode(s, <span class="number">1</span>)</span><br><span class="line">  fmt.Println(tree2str(s))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org41e41b3" class="outline-3">
<h3 id="org41e41b3"><a id="ID-6b0ba0ac-cf81-4f19-96fe-9de17becc534"></a><span class="section-number-3">3.9</span> convert sorted list to bst</h3>
<div class="outline-text-3" id="text-3-9">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> {</span><br><span class="line">  Val  <span class="typename">int</span></span><br><span class="line">  Next *ListNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> {</span><br><span class="line">  Val   <span class="typename">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> sortedListToBST(head *ListNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> head == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line">  length := getListLength(head)</span><br><span class="line">  <span class="keyword">return</span> sortedListToBSTHelper(head, length)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> getListLength(head *ListNode) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> head == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + getListLength(head.Next)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> getListNth(head *ListNode, nth <span class="typename">int</span>) *ListNode {</span><br><span class="line">  <span class="keyword">if</span> head == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> nth &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getListNth(head.Next, nth-<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> sortedListToBSTHelper(head *ListNode, length <span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> length &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> length == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val: head.Val,</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> length == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">      Val: head.Val,</span><br><span class="line">      Right: &amp;amp;TreeNode{</span><br><span class="line">        Val: head.Next.Val,</span><br><span class="line">      },</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  mid := length / <span class="number">2</span></span><br><span class="line">  mid_node := getListNth(head, mid)</span><br><span class="line">  <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">    Val:   mid_node.Val,</span><br><span class="line">    Left:  sortedListToBSTHelper(head, mid),</span><br><span class="line">    Right: sortedListToBSTHelper(mid_node.Next, length-<span class="number">1</span>-mid),</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  sortedLst := &amp;amp;ListNode{</span><br><span class="line">    Val: <span class="number">1</span>,</span><br><span class="line">    Next: &amp;amp;ListNode{</span><br><span class="line">      Val:<span class="number">2</span>,</span><br><span class="line">      Next: &amp;amp;ListNode{</span><br><span class="line">        Val:<span class="number">3</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line">  fmt.Println(tree2str(sortedListToBST(sortedLst)))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-org829f367" class="outline-3">
<h3 id="org829f367"><a id="ID-6847ceb5-0635-4cc1-b27e-ee2ba3f1fb66"></a><span class="section-number-3">3.10</span> kth smallest elemen</h3>
<div class="outline-text-3" id="text-3-10">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KthNode <span class="keyword">struct</span> {</span><br><span class="line">  K   <span class="typename">int</span></span><br><span class="line">  Val <span class="typename">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> traversalFunc <span class="keyword">func</span>(*TreeNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> kthSmallest(root *TreeNode, k <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  kNode := &amp;amp;KthNode{K: k}</span><br><span class="line">  tfunc := <span class="keyword">func</span>(knode *KthNode) traversalFunc {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">func</span>(node *TreeNode) {</span><br><span class="line">      kthFunc(node, knode)</span><br><span class="line">    }</span><br><span class="line">  }(kNode)</span><br><span class="line">  inorderTraversal(root, tfunc)</span><br><span class="line">  <span class="keyword">return</span> kNode.Val</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> inorderTraversal(root *TreeNode, tfunc traversalFunc) {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  inorderTraversal(root.Left, tfunc)</span><br><span class="line">  tfunc(root)</span><br><span class="line">  inorderTraversal(root.Right, tfunc)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> kthFunc(node *TreeNode, kn *KthNode) {</span><br><span class="line">  <span class="keyword">if</span> node == <span class="constant">nil</span> &amp;amp;&amp;amp; kn.K == <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  kn.K -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> kn.K == <span class="number">0</span> {</span><br><span class="line">    kn.Val = node.Val</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  t := &amp;amp;TreeNode{</span><br><span class="line">    Val: <span class="number">3</span>,</span><br><span class="line">    Left: &amp;amp;TreeNode{Val: <span class="number">2</span>},</span><br><span class="line">    Right: &amp;amp;TreeNode{Val: <span class="number">5</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fmt.Println(kthSmallest(t,<span class="number">1</span>))</span><br><span class="line">  fmt.Println(kthSmallest(t,<span class="number">2</span>))</span><br><span class="line">  fmt.Println(kthSmallest(t,<span class="number">3</span>))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-orgc3264fa" class="outline-3">
<h3 id="orgc3264fa"><a id="ID-949286c8-d2a4-465d-81aa-307003bc6509"></a><span class="section-number-3">3.11</span> unique bst</h3>
<div class="outline-text-3" id="text-3-11">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> numTrees(n <span class="typename">int</span>) <span class="typename">int</span> {</span><br><span class="line">  <span class="keyword">if</span> n &amp;lt; <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ctl_arr := <span class="built_in">make</span>([]<span class="typename">int</span>, n+<span class="number">1</span>)</span><br><span class="line">  ctl_arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  ctl_arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">2</span>; i &amp;lt; n+<span class="number">1</span>; i += <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &amp;lt; i; j += <span class="number">1</span> {</span><br><span class="line">      ctl_arr[i] += ctl_arr[j] * ctl_arr[i-j-<span class="number">1</span>]</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctl_arr[n]</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  <span class="keyword">for</span> _, n := <span class="keyword">range</span> list{</span><br><span class="line">    fmt.Println(numTrees(n))</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>

<div id="outline-container-org249176e" class="outline-3">
<h3 id="org249176e"><a id="ID-7c4cf8f8-6db0-49eb-9daa-abe9cd610bce"></a><span class="section-number-3">3.12</span> unique bst II</h3>
<div class="outline-text-3" id="text-3-12">
<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> generateTrees(n <span class="typename">int</span>) []*TreeNode {</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> []*TreeNode{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  tree_arr := []*TreeNode{</span><br><span class="line">    &amp;amp;TreeNode{</span><br><span class="line">      Val: <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">2</span>; i &amp;lt;= n; i += <span class="number">1</span> {</span><br><span class="line">    ng_tree_arr := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> tree_arr {</span><br><span class="line">      tree := tree_arr[index]</span><br><span class="line">      ng_tree_arr = <span class="built_in">append</span>(ng_tree_arr, genTreesHelper(tree, i)...)</span><br><span class="line">    }</span><br><span class="line">    tree_arr = ng_tree_arr</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tree_arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> genTreesHelper(root *TreeNode, greater <span class="typename">int</span>) []*TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> []*TreeNode{}</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  cr := cloneTree(root)</span><br><span class="line">  right := cr</span><br><span class="line">  <span class="keyword">var</span> parent *TreeNode</span><br><span class="line">  tree_arr := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">if</span> right != <span class="constant">nil</span> {</span><br><span class="line">      rval := right.Val</span><br><span class="line">      node := &amp;amp;TreeNode{</span><br><span class="line">        Val:  greater,</span><br><span class="line">        Left: right,</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> parent != <span class="constant">nil</span> {</span><br><span class="line">        parent.Right = node</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        cr = node</span><br><span class="line">      }</span><br><span class="line">      tree_arr = <span class="built_in">append</span>(tree_arr, cr)</span><br><span class="line"></span><br><span class="line">      cr = cloneTree(root)</span><br><span class="line">      parent = getNode(cr, rval)</span><br><span class="line">      right = parent.Right</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      parent.Right = &amp;amp;TreeNode{Val: greater}</span><br><span class="line">      tree_arr = <span class="built_in">append</span>(tree_arr, cr)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tree_arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> cloneTree(root *TreeNode) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;amp;TreeNode{</span><br><span class="line">    Val:   root.Val,</span><br><span class="line">    Left:  cloneTree(root.Left),</span><br><span class="line">    Right: cloneTree(root.Right),</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> getNode(root *TreeNode, val <span class="typename">int</span>) *TreeNode {</span><br><span class="line">  <span class="keyword">if</span> root == <span class="constant">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val == val {</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root.Val &amp;lt; val {</span><br><span class="line">    <span class="keyword">return</span> getNode(root.Right, val)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> getNode(root.Left, val)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>

<div class="org-src-container">
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() {</span><br><span class="line">  <span class="keyword">for</span> _, n := <span class="keyword">range</span> list{</span><br><span class="line">    tree_arr := generateTrees(n)</span><br><span class="line">    fmt.Println(n, <span class="built_in">len</span>(tree_arr))</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
</div>

Last Updated 2017-07-16 Sun 15:30.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" rel="external nofollow noopener noreferrer" target="_blank">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" rel="external nofollow noopener noreferrer" target="_blank">Emacs</a> 24.5.1 (<a href="http://orgmode.org" rel="external nofollow noopener noreferrer" target="_blank">Org</a> mode 9.0.6)

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
            <a href="/tags/tree/" rel="tag"># tree</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/16/leetcode-array/" rel="next" title="Leetcode-array">
                <i class="fa fa-chevron-left"></i> Leetcode-array
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/22/scrapy-crawl-zhihu/" rel="prev" title="scrapy模拟登陆知乎">
                scrapy模拟登陆知乎 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      
      
      
        <h3 class="article-title" style="font-size: 20px;">相关文章</h3>
        <ul class="related-posts">
        
            <li class="related-posts-item"><a href="https://brantou.github.io//2017/07/16/leetcode-array/">Leetcode-array</a></li>
        
            <li class="related-posts-item"><a href="https://brantou.github.io//2017/03/21/leetcode/">Leetcode编程练习</a></li>
        
        </ul>
      
      

    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="hypercomments_widget"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/26197076?v=3&s=400" alt="Brantou">
          <p class="site-author-name" itemprop="name">Brantou</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/brantou" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/brantou89" target="_blank" title="Twitter" rel="external nofollow noopener noreferrer">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#org81666c9"><span class="nav-text">1 binary tree traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#org95bc559"><span class="nav-text">1.1 level order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org4916f8b"><span class="nav-text">1.2 level order bottom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org99589c8"><span class="nav-text">1.3 zigzag level order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org179b5a7"><span class="nav-text">1.4 inOrder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org48a0b0d"><span class="nav-text">1.5 preOrder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgf465e82"><span class="nav-text">1.6 postOrder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#org9e72340"><span class="nav-text">2 binary tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#orgce4fb9f"><span class="nav-text">2.1 max depth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org947f8b1"><span class="nav-text">2.2 paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org641702f"><span class="nav-text">2.3 isBalanced</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgbb0984c"><span class="nav-text">2.4 invert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org4738885"><span class="nav-text">2.5 tilt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org573adcb"><span class="nav-text">2.6 construct string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org2e15e63"><span class="nav-text">2.7 symmetric</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org007aba8"><span class="nav-text">2.8 subtree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org7218791"><span class="nav-text">2.9 diameter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org203bb5e"><span class="nav-text">2.10 count complete tree nodes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org31d1237"><span class="nav-text">2.11 implement trie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org9d1032b"><span class="nav-text">2.12 merge two binary tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org257add8"><span class="nav-text">2.13 flatten bt to linked list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgc380c5d"><span class="nav-text">2.14 sum of left leaves</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org2ca0ba3"><span class="nav-text">2.15 find bottom left tree value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org47816be"><span class="nav-text">2.16 right side view</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org185b32e"><span class="nav-text">2.17 find largest value in each tree row</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgeb9e78e"><span class="nav-text">2.18 most frequent subtree sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgb18b487"><span class="nav-text">2.19 construct binary tree from preorder and inorder traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org5105443"><span class="nav-text">2.20 construct binary tree from inorder and postorder traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgd015965"><span class="nav-text">2.21 populating next right pointers in each node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org2642c0d"><span class="nav-text">2.22 add one row to tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org8a9cddd"><span class="nav-text">2.23 lowest common ancestor of a bt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org4454e8a"><span class="nav-text">2.24 serialize and deserialize bt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org03d5a15"><span class="nav-text">2.25 average of levels in binary tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org3fd398c"><span class="nav-text">2.26 TODO house robber III</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#orgd6bb2d9"><span class="nav-text">3 bst</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#org1f1e469"><span class="nav-text">3.1 BSTIterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org5c97f54"><span class="nav-text">3.2 to greater tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgca420d1"><span class="nav-text">3.3 validate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org43f72e4"><span class="nav-text">3.4 find mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orge41cb44"><span class="nav-text">3.5 convert sorted array to bst</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org5d2f1cc"><span class="nav-text">3.6 lowest common ancestor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org7672421"><span class="nav-text">3.7 recover binary search tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org43f3eae"><span class="nav-text">3.8 delete node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org41e41b3"><span class="nav-text">3.9 convert sorted list to bst</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org829f367"><span class="nav-text">3.10 kth smallest elemen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orgc3264fa"><span class="nav-text">3.11 unique bst</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#org249176e"><span class="nav-text">3.12 unique bst II</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Brantou</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow noopener noreferrer" target="_blank">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 89947, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 89947, xid: "2017/07/16/leetcode-tree/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/89947/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
