{"md5":"3b37aeb163f7fe8f5feba0d8149821b9","content":"\n\n<p>\n<i>Race conditions</i> 是最隐晦和难以捉摸的编程错误之一。\n通常，在代码部署到生产之后很长时间才会发作，而且通常会导致很神秘的故障。\nGo的并发机制使得编写干净并发代码变得容易，但它们并不能防止 /Race conditions/。\n需要谨慎，勤勉和测试。 工具很有帮助。\n</p>\n\n<p>\nGo 1.1引入竞态检测器，一个用于在Go代码中查找 <i>Race conditions</i> 的新工具。\n它基于 <i>C/C++ ThreadSanitizer运行库</i> ，此库被用于检测Google内部代码库和Chromium中的许多错误。\n该技术于2012年9月与Go集成; 此后，它已经应用到了标准库中。\n它现在已经成为持续建设过程的一部分，在这些过程中，它们会随着时间的推移而捕捉到产生的 <i>Race conditions</i> 。\n</p>\n\n<div id=\"outline-container-orga1fec1e\" class=\"outline-2\">\n<h2 id=\"orga1fec1e\"><span class=\"section-number-2\">1</span> 工作原理</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n竞态探测器集成在go工具链中。\n当设置了-race命令行标志时，编译器将使用访问内存的时间和方式的代码记录下来,用于设置所有内存访问，\n而运行时库会监视对共享变量的不同步访问。 当检测到这种“racy”行为时，会打印一个警告。\n</p>\n\n<p>\n由于其设计，竞态探测器只能在运行代码实际触发时才能检测到竞争条件，这意味着需要在真实的工作负载下运行启用探测器。\n然而，启用竞态探测的可执行文件可能使用十倍的CPU和内存，因此始终启用探测器是不切实际的。\n出于这个困境的一个办法是在启用竞态探测的情况下运行一些测试。\n负载测试和集成测试是很好的候选者，因为它们往往会执行代码的并发部分。\n另外的可选途径：生产工作负载环境中, 在运行的服务器池中, 部署单个启用竞态探测的实例。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org319b650\" class=\"outline-2\">\n<h2 id=\"org319b650\"><span class=\"section-number-2\">2</span> 使用</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\n竞态探测器与Go工具链完全集成。 要启用竞态检测器的情况下,构建代码，只需将 <i>-race</i> 标志添加到命令行：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go <span class=\"built_in\">test</span> -race mypkg    // <span class=\"built_in\">test</span> the package</span><br><span class=\"line\">go run -race mysrc.go  // compile and run the program</span><br><span class=\"line\">go build -race mycmd   // build the <span class=\"built_in\">command</span></span><br><span class=\"line\">go install -race mypkg // install the package</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgf08c77e\" class=\"outline-2\">\n<h2 id=\"orgf08c77e\"><span class=\"section-number-2\">3</span> 示例</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-org85502e1\" class=\"outline-3\">\n<h3 id=\"org85502e1\"><span class=\"section-number-3\">3.1</span> Timer.Reset</h3>\n<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\n当前例子是竞态探测器发现的实际bug的简化版本。\n在使用定时器, 0到1秒的随机时间间隔之后打印消息。 打印过程反复进行了五秒钟。\n使用 <code>time.AfterFunc</code> 为第一条消息创建一个 <code>Timer</code> ，然后使用 <code>Reset</code> 方法调度下一条消息，每次都复用原有 <code>Timer</code> 。\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> main() {</span><br><span class=\"line\">  runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class=\"line\">  start := time.Now()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t *time.Timer</span><br><span class=\"line\">  t = time.AfterFunc(randomDuration(), <span class=\"keyword\">func</span>() {</span><br><span class=\"line\">    fmt.Println(time.Now().Sub(start))</span><br><span class=\"line\">    t.Reset(randomDuration())</span><br><span class=\"line\">  })</span><br><span class=\"line\">  time.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> randomDuration() time.Duration {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> time.Duration(rand.Int63n(<span class=\"number\">1e9</span>))</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n这似乎是合理的代码，但在某些情况下，它以令人惊讶的方式失败：\n</p>\n<pre class=\"example\">\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal 0xb code=0x1 addr=0x8 pc=0x41e38a]\n\ngoroutine 4 [running]:\ntime.stopTimer(0x8, 0x12fe6b35d9472d96)\n    src/pkg/runtime/ztime_linux_amd64.c:35 +0x25\ntime.(*Timer).Reset(0x0, 0x4e5904f, 0x1)\n    src/pkg/time/sleep.go:81 +0x42\nmain.func·001()\n    race.go:14 +0xe3\ncreated by time.goFunc\n    src/pkg/time/sleep.go:122 +0x48\n</pre>\n\n<p>\n发生了什么？ 启用竞态探测器的然后在运行一次：\n</p>\n<pre class=\"example\">\n==================\nWARNING: DATA RACE\nRead at 0x00c420084018 by goroutine 7:\n  main.main.func1()\n      /tmp/babel-27165ee_/go-src-27165GUv.go:17 +0x17c\n\nPrevious write at 0x00c420084018 by main goroutine:\n  main.main()\n      /tmp/babel-27165ee_/go-src-27165GUv.go:18 +0x17a\n\nGoroutine 7 (running) created at:\n  time.goFunc()\n      /home/parallels/.gvm/gos/go1.8/src/time/sleep.go:170 +0x51\n==================\nFound 1 data race(s)\nexit status 66\n</pre>\n\n<p>\n竞态探测器展示出问题根源：来自不同 <code>goroutines</code> 对变量 <i>t</i> 有不同步读和写。\n如果初始定时器时间间隔非常小，则定时器函数可能会在主 <code>goroutine</code> 赋值到 <i>t</i> 之前触发，因此对 <i>t.Reset</i> 的调用发生在 <i>nil</i> 上。\n</p>\n\n<p>\n修复这个 <i>race condition</i> 问题，可通过读写发生在一个 <code>goroutine</code> 中：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> main() {</span><br><span class=\"line\">  runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class=\"line\">  start := time.Now()</span><br><span class=\"line\">  reset := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"typename\">bool</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t *time.Timer</span><br><span class=\"line\">  t = time.AfterFunc(randomDuration(), <span class=\"keyword\">func</span>() {</span><br><span class=\"line\">    fmt.Println(time.Now().Sub(start))</span><br><span class=\"line\">    reset &amp;lt;- <span class=\"constant\">true</span></span><br><span class=\"line\">  })</span><br><span class=\"line\">  <span class=\"keyword\">for</span> time.Since(start) &amp;lt; <span class=\"number\">5</span>*time.Second {</span><br><span class=\"line\">    &amp;lt;-reset</span><br><span class=\"line\">    t.Reset(randomDuration())</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> randomDuration() time.Duration {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> time.Duration(rand.Int63n(<span class=\"number\">1e9</span>))</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n主 <code>goroutine</code> 完全负责设置和重置定时器 <i>t</i> ，通过一个新的重置 <code>channel</code> 传达重置定时器的信号，然后以线程安全的方式重置定时器。\n</p>\n\n<p>\n最简单但不相对不那么高效的方式是<a href=\"http://play.golang.org/p/kuWTrY0pS4\">避免复用timer</a>。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org764fbe4\" class=\"outline-3\">\n<h3 id=\"org764fbe4\"><span class=\"section-number-3\">3.2</span> ioutil.Discard</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\nioutil包的 <i>Discard</i> 实现了接口 <i>io.Writer</i> , 但是忽略了所有写给它的数据。 可认为如 <i>dev/null 一般：发送你需要读取而不需要存储的数据的一个地方。\n它通常与 /io.Copy</i> 一起使用，清空reader，如下所示：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.Copy(ioutil.Discard, reader)</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n回到2011年7月，Go团队注意到，以这种方式使用Discard效率不高：Copy功能在每次调用时内部都会分配一个 <i>32kB</i> 的缓冲区，\n但是当与 <i>Discard</i> 一起使用时，缓冲区完全没必要，因为只是丢弃读取到的数据。\n他们认为这种惯用的复制和丢弃不应该那么昂贵。修复此问题的方式，就是给 <i>Writer</i> 实现方法 <i>ReadFrom</i>,如下所示：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">writer.ReadFrom(reader)</span><br></pre></td></tr></table></figure>\n</div>\n<p>\nGo团队向 <i>Discard</i> 的底层类型添加了一个ReadFrom方法，该类型具有内部缓冲区，该缓冲区在其所有用户之间共享。\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> blackHole [<span class=\"number\">4096</span>]<span class=\"typename\">byte</span> <span class=\"comment\">// shared buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> (devNull) ReadFrom(r io.Reader) (n <span class=\"typename\">int64</span>, err error) {</span><br><span class=\"line\">    readSize := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> {</span><br><span class=\"line\">        readSize, err = r.Read(blackHole[:])</span><br><span class=\"line\">        n += <span class=\"typename\">int64</span>(readSize)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"constant\">nil</span> {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == io.EOF {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n, <span class=\"constant\">nil</span></span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n这次修复依旧没能解决问题，因为用户自定义的 /Reader/，可能在读的过程中，执行写操作，这个时候共享的缓冲区就造成数据污染。\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> trackDigestReader <span class=\"keyword\">struct</span> {</span><br><span class=\"line\">  r io.Reader</span><br><span class=\"line\">  h hash.Hash</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> (t trackDigestReader) Read(p []<span class=\"typename\">byte</span>) (n <span class=\"typename\">int</span>, err error) {</span><br><span class=\"line\">  n, err = t.r.Read(p) <span class=\"comment\">//  &amp;#36825;&amp;#37324;&amp;#30340;p&amp;#23601;&amp;#26159;&amp;#20195;&amp;#34920;&amp;#30340;&amp;#23601;&amp;#26159;balckHode</span></span><br><span class=\"line\">  t.h.Write(p[:n])</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">tdr := trackDigestReader{r: file, h: sha1.New()}</span><br><span class=\"line\">io.Copy(ioutil.Discard, tdr)</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n最终还是通过为每次使用的 <i>ioutil.Discard</i> 添加唯一的缓冲区，来消除共享缓冲区的 <i>Race condition</i> 。\n</p>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orge115932\" class=\"outline-2\">\n<h2 id=\"orge115932\"><span class=\"section-number-2\">4</span> 总结</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\n竞态探测器是检查并发程序正确性的强大工具。 它不会呈现虚假问题，所以请认真地对待。\n</p>\n\n<p>\n还在等什么？现在就对你的代码运行“go test -race”吧！\n</p>\n</div>\n</div>\n\nLast Updated 2017-05-23 Tue 18:35.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 24.5.1 (<a href=\"http://orgmode.org\">Org</a> mode 9.0.6)\n"}
